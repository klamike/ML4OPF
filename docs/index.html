<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>ml4opf API documentation</title>
<meta name="description" content="ML4OPF: Machine Learning for OPF
â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>ml4opf</code></h1>
</header>
<section id="section-intro">
<h2 id="ml4opf-machine-learning-for-opf">ML4OPF: Machine Learning for OPF</h2>
<p>This repository contains a collection of tools for applying machine learning
to the optimal power flow (OPF) problem. Below are some common usage patterns:</p>
<h2 id="loading-data">Loading data</h2>
<p>This is probably the most common usage, especially for those who
already have their own models and wish to evaluate on the OPFGenerator
datasets. ML4OPF makes loading data and splitting training/testing sets
easy and reproducible.</p>
<pre><code class="language-python">from ml4opf import DCPProblem

data_dir = ... # path to folder containing the data
case_name = ... # e.g. &quot;300_ieee&quot; if the files are &quot;300_ieee_DCOPF.h5&quot; and &quot;300_ieee.ref.json&quot;
dataset_name = ... # the name of the dataset, e.g. &quot;DCOPF&quot;

problem = DCPProblem(data_dir, case_name, dataset_name, **kwargs)

# extract tensors
train_pd = problem.train_data[&quot;input/pd&quot;]
train_pg = problem.train_data[&quot;primal/pg&quot;]
train_va = problem.train_data[&quot;primal/va&quot;]

test_pd = problem.test_data[&quot;input/pd&quot;]
test_pg = problem.test_data[&quot;primal/pg&quot;]
test_va = problem.test_data[&quot;primal/va&quot;]

# create a PyTorch dataset
torch_dataset, slices = problem.make_dataset()
</code></pre>
<h2 id="computing-residuals">Computing residuals</h2>
<p>The ML4OPF OPFViolation modules provide a fast (using <code>torch.jit</code>),
standard, and convenient way to: calculate the residuals/violations
of the OPF constraints, compute the objective function,
and other useful problem data such as incidence matrices.</p>
<pre><code class="language-python">v = problem.violation
pg_lower, pg_upper = v.pg_bound_residual(train_pg) # supply clamp=True to report violations only
obj = v.objective(train_pg)
gen_incidence = v.generator_incidence
</code></pre>
<p>Note that you can use the underlying functions directly without instantiating
the OPFViolation class by accessing <code><a title="ml4opf.functional" href="functional/index.html">ml4opf.functional</a></code>.
This allows to perform the calculations without using the data parsing or caching logic,
but requires the user to adopt the functional interface (<code><a title="ml4opf.functional" href="functional/index.html">ml4opf.functional</a></code>) vs. the object-oriented interface (<code><a title="ml4opf.formulations" href="formulations/index.html">ml4opf.formulations</a></code>).</p>
<pre><code class="language-python">import ml4opf.functional as MOF
gen_incidence = MOF.generator_incidence(v.gen_bus, v.n_bus, v.n_gen)
obj = MOF.DCP.objective(train_pg, v.cost)
</code></pre>
<h2 id="implementing-an-opfmodel">Implementing an OPFModel</h2>
<p>In order to use the ML4OPF evaluation tools, you need to subclass the
<code><a title="ml4opf.OPFModel" href="#ml4opf.OPFModel">OPFModel</a></code> class and implement a few methods. The typical pattern is to
first write your model in the typical PyTorch fashion - subclassing <code>torch.nn.Module</code>.
Then, subclass <code><a title="ml4opf.OPFModel" href="#ml4opf.OPFModel">OPFModel</a></code> and implement the required methods. Below is an example
where the original model is <code>MyPyTorchModel</code> and the wrapper is <code>MyDCPModel</code>.</p>
<pre><code class="language-python">import torch
from ml4opf import DCPModel

N_LOADS = problem.violation.n_load
N_GEN = problem.violation.n_gen
N_BUS = problem.violation.n_bus

class MyPyTorchModel(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = torch.nn.Linear(N_LOADS, 16)
        self.fc2 = torch.nn.Linear(16, N_GEN)
        self.fc3 = torch.nn.Linear(16, N_BUS)

    def forward(self, pd):
        x = torch.relu(self.fc1(pd))
        pg_pred = self.fc2(x)
        va_pred = self.fc3(x)
        return pg_pred, va_pred

class MyDCPModel(DCPModel):
    def __init__(self, pytorch_model, problem):
        super().__init__()
        self.model = pytorch_model
        self.problem = problem

    def save_checkpoint(self, path_to_folder):
        torch.save(self.model.state_dict(), f&quot;{path_to_folder}/model.pth&quot;)

    @classmethod
    def load_from_checkpoint(cls, path_to_folder, problem):
        pytorch_model = MyPyTorchModel()
        pytorch_model.load_state_dict(torch.load(f&quot;{path_to_folder}/model.pth&quot;))
        return cls(pytorch_model, problem)

    def predict(self, pd):
        pg, va = self.model(pd)
        return {&quot;pg&quot;: pg, &quot;va&quot;: va}
</code></pre>
<h2 id="using-repair-layers">Using repair layers</h2>
<p>A common issue with learning OPF is that the model may predict
infeasible solutions. The <code><a title="ml4opf.layers" href="layers/index.html">ml4opf.layers</a></code> module provides a collection
of differentiable layers that can be used to repair infeasible solutions. For example,
the <code><a title="ml4opf.BoundRepair" href="#ml4opf.BoundRepair">BoundRepair</a></code> layer can be used to repair solutions that violate
bound constraints. The output of <code><a title="ml4opf.BoundRepair" href="#ml4opf.BoundRepair">BoundRepair</a></code> is guaranteed to be within
the specified bounds.</p>
<pre><code class="language-python">from ml4opf.layers import BoundRepair

class BoundRepairPyTorchModel(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = torch.nn.Linear(N_LOADS, 16)
        self.fc2 = torch.nn.Linear(16, N_GEN)
        self.fc3 = torch.nn.Linear(16, N_BUS)
        self.bound_repair = BoundRepair(xmin=v.pmin, xmax=v.pmax, method=&quot;softplus&quot;)

    def forward(self, pd):
        x = torch.relu(self.fc1(pd))
        pg_pred = self.bound_repair(self.fc2(x))
        va_pred = self.fc3(x)
        return pg_pred, va_pred
</code></pre>
<p>The source code is organized into
several submodules:</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="ml4opf.formulations" href="formulations/index.html">ml4opf.formulations</a></code></dt>
<dd>
<div class="desc"><p>ML4OPF Formulations</p></div>
</dd>
<dt><code class="name"><a title="ml4opf.functional" href="functional/index.html">ml4opf.functional</a></code></dt>
<dd>
<div class="desc"><p>Functional interface</p></div>
</dd>
<dt><code class="name"><a title="ml4opf.layers" href="layers/index.html">ml4opf.layers</a></code></dt>
<dd>
<div class="desc"><p>ML4OPF Layers</p></div>
</dd>
<dt><code class="name"><a title="ml4opf.loss_functions" href="loss_functions/index.html">ml4opf.loss_functions</a></code></dt>
<dd>
<div class="desc"><p>ML4OPF Loss Functions</p></div>
</dd>
<dt><code class="name"><a title="ml4opf.models" href="models/index.html">ml4opf.models</a></code></dt>
<dd>
<div class="desc"><p>ML4OPF Models
â€¦</p></div>
</dd>
<dt><code class="name"><a title="ml4opf.parsers" href="parsers/index.html">ml4opf.parsers</a></code></dt>
<dd>
<div class="desc"><p>ML4OPF Parsers</p></div>
</dd>
<dt><code class="name"><a title="ml4opf.viz" href="viz/index.html">ml4opf.viz</a></code></dt>
<dd>
<div class="desc"><p>Visualization utilities (plots &amp; tables)</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ml4opf.ACPModel"><code class="flex name class">
<span>class <span class="ident">ACPModel</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.OPFModel" href="#ml4opf.OPFModel">OPFModel</a></code> for ACPPowerModel/ACOPF</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/acp/model.py#L10-L135" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.model.OPFModel" href="formulations/model.html#ml4opf.formulations.model.OPFModel">OPFModel</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.acp.model.PerfectACPModel" href="formulations/acp/model.html#ml4opf.formulations.acp.model.PerfectACPModel">PerfectACPModel</a></li>
<li><a title="ml4opf.models.basic_nn.acp_basic_nn.ACPBasicNeuralNet" href="models/basic_nn/acp_basic_nn.html#ml4opf.models.basic_nn.acp_basic_nn.ACPBasicNeuralNet">ACPBasicNeuralNet</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ml4opf.ACPModel.problem"><code class="name">var <span class="ident">problem</span> :Â <a title="ml4opf.formulations.acp.problem.ACPProblem" href="formulations/acp/problem.html#ml4opf.formulations.acp.problem.ACPProblem">ACPProblem</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ml4opf.ACPModel.violation"><code class="name">var <span class="ident">violation</span> :Â <a title="ml4opf.formulations.acp.violation.ACPViolation" href="formulations/acp/violation.html#ml4opf.formulations.acp.violation.ACPViolation">ACPViolation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.ACPModel.evaluate_model"><code class="name flex">
<span>def <span class="ident">evaluate_model</span></span>(<span>self, reduction:Â Optional[str]Â =Â None, inner_reduction:Â Optional[str]Â =Â None) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the model on the test data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reduction</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reduction method for the metrics. Defaults to None. Must be one of "mean", "sum","max", "none".
If specified, each value in the returned dictionary will be a scalar. Otherwise, they are arrays of shape (n_test_samples,)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>
<p>Dictionary containing Tensor metrics of the model's performance.</p>
<p><code>vm_lower</code>: Lower bound on the voltage magnitude.</p>
<p><code>vm_upper</code>: Upper bound on the voltage magnitude.</p>
<p><code>pg_lower</code>: Lower bound on the real power generation.</p>
<p><code>pg_upper</code>: Upper bound on the real power generation.</p>
<p><code>qg_lower</code>: Lower bound on the reactive power generation.</p>
<p><code>qg_upper</code>: Upper bound on the reactive power generation.</p>
<p><code>thrm_1</code>: Thermal limit violation from</p>
<p><code>thrm_2</code>: Thermal limit violation to</p>
<p><code>p_balance</code>: Active power balance violation.</p>
<p><code>q_balance</code>: Reactive power balance violation.</p>
<p><code>pg_gap</code>: Mean absolute error of the real power generation.</p>
<p><code>qg_gap</code>: Mean absolute error of the reactive power generation.</p>
<p><code>vm_gap</code>: Mean absolute error of the voltage magnitude.</p>
<p><code>va_gap</code>: Mean absolute error of the voltage angle. (if not bus-wise and va not in predictions, skipped)</p>
<p><code>dva_gap</code>: Mean absolute error of the angle difference. (only if not bus-wise)</p>
<p><code>obj_mape</code>: Mean absolute percent error of the objective value.</p>
</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPModel.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, pd:Â torch.Tensor, qd:Â torch.Tensor) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the ACOPF primal solution for a given set of loads.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power demand per load.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power demand per load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>
<p>Dictionary containing the predicted primal solution.</p>
<p><code>pg</code>: Active power generation per generator or per bus.</p>
<p><code>qg</code>: Reactive power generation per generator or per bus.</p>
<p><code>vm</code>: Voltage magnitude per bus.</p>
<p><code>va</code>: Voltage angle per bus.</p>
</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.model.OPFModel" href="formulations/model.html#ml4opf.formulations.model.OPFModel">OPFModel</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.model.OPFModel.load_from_checkpoint" href="formulations/model.html#ml4opf.formulations.model.OPFModel.load_from_checkpoint">load_from_checkpoint</a></code></li>
<li><code><a title="ml4opf.formulations.model.OPFModel.save_checkpoint" href="formulations/model.html#ml4opf.formulations.model.OPFModel.save_checkpoint">save_checkpoint</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.ACPProblem"><code class="flex name class">
<span>class <span class="ident">ACPProblem</span></span>
<span>(</span><span>data_directory:Â str, case_name:Â str, dataset_name:Â strÂ =Â 'ACOPF', **parse_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.OPFProblem" href="#ml4opf.OPFProblem">OPFProblem</a></code> for ACPPowerModel/ACOPF</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/acp/problem.py#L9-L78" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.problem.OPFProblem" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem">OPFProblem</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ml4opf.ACPProblem.default_combos"><code class="name">prop <span class="ident">default_combos</span> :Â dict[str,Â list[str]]</code></dt>
<dd>
<div class="desc"><p>Default combos for ACOPF:</p>
<ul>
<li>
<p>input: pd, qd</p>
</li>
<li>
<p>target: pg, qg, vm, va</p>
</li>
</ul></div>
</dd>
<dt id="ml4opf.ACPProblem.default_order"><code class="name">prop <span class="ident">default_order</span> :Â list[str]</code></dt>
<dd>
<div class="desc"><p>Default order for ACOPF: input, target</p></div>
</dd>
<dt id="ml4opf.ACPProblem.feasibility_check"><code class="name">prop <span class="ident">feasibility_check</span> :Â dict[str,Â str]</code></dt>
<dd>
<div class="desc"><p>Default feasibility check for ACOPF:</p>
<ul>
<li>
<p>termination_status: "LOCALLY_SOLVED"</p>
</li>
<li>
<p>primal_status: "FEASIBLE_POINT"</p>
</li>
<li>
<p>dual_status: "FEASIBLE_POINT"</p>
</li>
</ul></div>
</dd>
<dt id="ml4opf.ACPProblem.violation"><code class="name">prop <span class="ident">violation</span> :Â <a title="ml4opf.formulations.acp.violation.ACPViolation" href="formulations/acp/violation.html#ml4opf.formulations.acp.violation.ACPViolation">ACPViolation</a></code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.ACPViolation" href="#ml4opf.ACPViolation">ACPViolation</a></code> object, created upon first access.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.problem.OPFProblem" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem">OPFProblem</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.problem.OPFProblem.default_parse_only" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.default_parse_only">default_parse_only</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.make_dataset" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.make_dataset">make_dataset</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.parse" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.parse">parse</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.slice_batch" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.slice_batch">slice_batch</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.slice_tensor" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.slice_tensor">slice_tensor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.ACPViolation"><code class="flex name class">
<span>class <span class="ident">ACPViolation</span></span>
<span>(</span><span>json_data:Â dict[str,Â typing.Union[bool,Â int,Â float,Â dict[str,Â torch.Tensor]]])</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code> for ACPPowerModel/ACOPF</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/acp/violation.py#L13-L413" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.violation.OPFViolation" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation">OPFViolation</a></li>
<li><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin">IncidenceMixin</a></li>
<li>torch.nn.modules.module.Module</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.ACPViolation.angle_difference"><code class="name flex">
<span>def <span class="ident">angle_difference</span></span>(<span>self, va:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle differences per branch given the voltage angles per bus.</p>
<p><span><span class="MathJax_Preview">
\text{dva} = \boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}
</span><script type="math/tex; mode=display">
\text{dva} = \boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>va</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angles per bus ( <span><span class="MathJax_Preview">\boldsymbol{\theta}</span><script type="math/tex">\boldsymbol{\theta}</script></span> ). (batch_size, nbus)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Angle differences per branch. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.balance_residual"><code class="name flex">
<span>def <span class="ident">balance_residual</span></span>(<span>self, pd:Â torch.Tensor, qd:Â torch.Tensor, pg:Â torch.Tensor, qg:Â torch.Tensor, vm:Â torch.Tensor, pf:Â torch.Tensor, pt:Â torch.Tensor, qf:Â torch.Tensor, qt:Â torch.Tensor, clamp:Â boolÂ =Â False, embed_method:Â strÂ =Â 'pad') â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the power balance residual.</p>
<p>Component-wise tensors are first embedded to the bus level using <code>embed_method</code>.</p>
<p>The shunt parameters <span><span class="MathJax_Preview"> g_s, b_s </span><script type="math/tex"> g_s, b_s </script></span> are assumed to be constant, matching the reference case.</p>
<p><span><span class="MathJax_Preview"> \text{p_viol} = \text{pg_bus} - \text{pd_bus} - \text{pt_bus} - \text{pf_bus} - \text{gs_bus} \times \text{vm}^2 </span><script type="math/tex; mode=display"> \text{p_viol} = \text{pg_bus} - \text{pd_bus} - \text{pt_bus} - \text{pf_bus} - \text{gs_bus} \times \text{vm}^2 </script></span>
<span><span class="MathJax_Preview"> \text{q_viol} = \text{qg_bus} - \text{qd_bus} - \text{qt_bus} - \text{qf_bus} + \text{bs_bus} \times \text{vm}^2 </span><script type="math/tex; mode=display"> \text{q_viol} = \text{qg_bus} - \text{qd_bus} - \text{qt_bus} - \text{qf_bus} + \text{bs_bus} \times \text{vm}^2 </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power demand per bus. (batch_size, nbus)</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power demand per bus. (batch_size, nbus)</dd>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>qg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>vm</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage magnitude per bus. (batch_size, nbus)</dd>
<dt><strong><code>pf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power flow from bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>pt</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power flow to bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>qf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power flow from bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>qt</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power flow to bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Apply an absolute value to the residual. Defaults to False.</dd>
<dt><strong><code>embed_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Embedding method for bus-level components. Defaults to 'pad'. Must be one of 'pad', 'dense_matrix', or 'matrix. See <code>IncidenceMixin.*_to_bus</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Power balance residual for active power. (batch_size, nbus)</dd>
<dt><code>Tensor</code></dt>
<dd>Power balance residual for reactive power. (batch_size, nbus)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.calc_violations"><code class="name flex">
<span>def <span class="ident">calc_violations</span></span>(<span>self, pd:Â torch.Tensor, qd:Â torch.Tensor, pg:Â torch.Tensor, qg:Â torch.Tensor, vm:Â torch.Tensor, va:Â Optional[torch.Tensor]Â =Â None, dva:Â Optional[torch.Tensor]Â =Â None, flows:Â Optional[tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor,Â torch.Tensor]]Â =Â None, reduction:Â Optional[str]Â =Â 'mean', clamp:Â boolÂ =Â True) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the violation of all the constraints.</p>
<p>The reduction is applied across the component dimension - e.g., 'mean' will do violation.mean(dim=1) where each violation is (batch, components)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Real power demand. (batch, loads)</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power demand. (batch, loads)</dd>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Real power generation. (batch, gens)</dd>
<dt><strong><code>qg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power generation. (batch, gens)</dd>
<dt><strong><code>vm</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage magnitude. (batch, buses)</dd>
<dt><strong><code>va</code></strong> :&ensp;<code>Tensor</code>, optional</dt>
<dd>Voltage angle. (batch, buses)</dd>
<dt><strong><code>dva</code></strong> :&ensp;<code>Tensor</code>, optional</dt>
<dd>Voltage angle difference. (batch, branches)</dd>
<dt><strong><code>flows</code></strong> :&ensp;<code>tuple[Tensor, Tensor, Tensor, Tensor]</code>, optional</dt>
<dd>Power flows. (pf, pt, qf, qt)</dd>
<dt><strong><code>reduction</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reduction method. Defaults to 'mean'. Must be one of 'mean', 'sum', 'none'.</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<ul>
<li>dict[str, Tensor]: Dictionary of violations.</li>
</ul>
<p><code>vm_lower</code>: Voltage magnitude lower bound violation.</p>
<p><code>vm_upper</code>: Voltage magnitude upper bound violation.</p>
<p><code>pg_lower</code>: Real power generation lower bound violation.</p>
<p><code>pg_upper</code>: Real power generation upper bound violation.</p>
<p><code>qg_lower</code>: Reactive power generation lower bound violation.</p>
<p><code>qg_upper</code>: Reactive power generation upper bound violation.</p>
<p><code>thrm_1</code>: Thermal limit from violation.</p>
<p><code>thrm_2</code>: Thermal limit to violation.</p>
<p><code>p_balance</code>: Real power balance violation.</p>
<p><code>q_balance</code>: Reactive power balance violation.</p>
<p><code>dva_lower</code>: Voltage angle difference lower bound violation.</p>
<p><code>dva_upper</code>: Voltage angle difference upper bound violation.</p></div>
</dd>
<dt id="ml4opf.ACPViolation.dva_bound_residual"><code class="name flex">
<span>def <span class="ident">dva_bound_residual</span></span>(<span>self, dva:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the voltage angle difference bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = \text{angmin} - \text{dva} </span><script type="math/tex; mode=display"> g_{\text{lower}} = \text{angmin} - \text{dva} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{dva} - \text{angmax} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{dva} - \text{angmax} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dva</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angle difference per branch. (batch_size, nbranch)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.flows_from_voltage"><code class="name flex">
<span>def <span class="ident">flows_from_voltage</span></span>(<span>self, vm:Â torch.Tensor, dva:Â torch.Tensor) â€‘>Â tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the power flows given the voltage magnitude per bus and angle differences per branch.</p>
<p>The branch (transformer + line) parameters <span><span class="MathJax_Preview"> g, b, g_f, b_f, g_t, b_t, t_r, t_i </span><script type="math/tex"> g, b, g_f, b_f, g_t, b_t, t_r, t_i </script></span> and <span><span class="MathJax_Preview"> \text{tap} </span><script type="math/tex"> \text{tap} </script></span>
are assumed to be constant <em>for the life of this object</em>, matching the reference case.
These constants are pre-computed using the <code>MOFACP._compute_flow_constants</code> function.</p>
<p><span><span class="MathJax_Preview"> \mathbf{p}_f = \frac{g + g_{f}}{\text{tap}^2} \mathbf{v}_{f}^2 + \frac{-g t_r + b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) + \frac{-b t_r - g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) </span><script type="math/tex; mode=display"> \mathbf{p}_f = \frac{g + g_{f}}{\text{tap}^2} \mathbf{v}_{f}^2 + \frac{-g t_r + b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) + \frac{-b t_r - g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) </script></span>
<span><span class="MathJax_Preview"> \mathbf{p}_t = (g + g_{t}) \mathbf{v}_{t}^2 + \frac{-g t_r - b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) + \frac{-b t_r + g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) </span><script type="math/tex; mode=display"> \mathbf{p}_t = (g + g_{t}) \mathbf{v}_{t}^2 + \frac{-g t_r - b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) + \frac{-b t_r + g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) </script></span>
<span><span class="MathJax_Preview"> \mathbf{q}_f = \frac{-(b + b_{f})}{\text{tap}^2} \mathbf{v}_{f}^2 - \frac{-b t_r - g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) + \frac{-g t_r + b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) </span><script type="math/tex; mode=display"> \mathbf{q}_f = \frac{-(b + b_{f})}{\text{tap}^2} \mathbf{v}_{f}^2 - \frac{-b t_r - g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) + \frac{-g t_r + b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) </script></span>
<span><span class="MathJax_Preview"> \mathbf{q}_t = -(b + b_{t}) \mathbf{v}_{t}^2 - \frac{-b t_r + g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) + \frac{-g t_r - b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) </span><script type="math/tex; mode=display"> \mathbf{q}_t = -(b + b_{t}) \mathbf{v}_{t}^2 - \frac{-b t_r + g t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \cos(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) + \frac{-g t_r - b t_i}{\text{tap}^2} \mathbf{v}_{f} \mathbf{v}_{t} \sin(\boldsymbol{\theta}_{t} - \boldsymbol{\theta}_{f}) </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vm</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage magnitude per bus ( <span><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span> ). (batch_size, nbus)</dd>
<dt><strong><code>dva</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Angle differences per branch ( <span><span class="MathJax_Preview"> \boldsymbol{\theta}_f - \boldsymbol{\theta}_t </span><script type="math/tex"> \boldsymbol{\theta}_f - \boldsymbol{\theta}_t </script></span> ). (batch_size, nbranch)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Real power flow per branch ( <span><span class="MathJax_Preview">\mathbf{p}_f</span><script type="math/tex">\mathbf{p}_f</script></span> ). (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Real power flow per branch ( <span><span class="MathJax_Preview">\mathbf{p}_t</span><script type="math/tex">\mathbf{p}_t</script></span> ). (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Reactive power flow per branch ( <span><span class="MathJax_Preview">\mathbf{q}_f</span><script type="math/tex">\mathbf{q}_f</script></span> ). (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Reactive power flow per branch ( <span><span class="MathJax_Preview">\mathbf{q}_t</span><script type="math/tex">\mathbf{q}_t</script></span> ). (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.flows_from_voltage_bus"><code class="name flex">
<span>def <span class="ident">flows_from_voltage_bus</span></span>(<span>self, vm:Â torch.Tensor, va:Â torch.Tensor) â€‘>Â tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the power flows given the voltage magnitude per bus and voltage angles per bus.</p>
<p>This function computes angle differences then calls <code><a title="ml4opf.ACPViolation.flows_from_voltage" href="#ml4opf.ACPViolation.flows_from_voltage">ACPViolation.flows_from_voltage()</a></code>.
See the docstring of <code><a title="ml4opf.ACPViolation.flows_from_voltage" href="#ml4opf.ACPViolation.flows_from_voltage">ACPViolation.flows_from_voltage()</a></code> for more details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vm</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage magnitude per bus ( <span><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span> ). (batch_size, nbus)</dd>
<dt><strong><code>va</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angle per bus ( <span><span class="MathJax_Preview">\boldsymbol{\theta}</span><script type="math/tex">\boldsymbol{\theta}</script></span> ). (batch_size, nbus)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Real power flow per branch ( <span><span class="MathJax_Preview">\mathbf{p}_f</span><script type="math/tex">\mathbf{p}_f</script></span> ). (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Real power flow per branch ( <span><span class="MathJax_Preview">\mathbf{p}_t</span><script type="math/tex">\mathbf{p}_t</script></span> ). (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Reactive power flow per branch ( <span><span class="MathJax_Preview">\mathbf{q}_f</span><script type="math/tex">\mathbf{q}_f</script></span> ). (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Reactive power flow per branch ( <span><span class="MathJax_Preview">\mathbf{q}_t</span><script type="math/tex">\mathbf{q}_t</script></span> ). (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.objective"><code class="name flex">
<span>def <span class="ident">objective</span></span>(<span>self, pg:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the objective function given the active power generation per generator.</p>
<p><span><span class="MathJax_Preview">
\text{objective} = \sum_{i=1}^{n} \text{cost}_{2,i} + \text{cost}_{1,i} \cdot \text{pg}_i
</span><script type="math/tex; mode=display">
\text{objective} = \sum_{i=1}^{n} \text{cost}_{2,i} + \text{cost}_{1,i} \cdot \text{pg}_i
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power generation per generator. (batch_size, ngen)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Objective function value. (batch_size)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.pg_bound_residual"><code class="name flex">
<span>def <span class="ident">pg_bound_residual</span></span>(<span>self, pg:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the active power generation bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = \text{pmin} - \text{pg} </span><script type="math/tex; mode=display"> g_{\text{lower}} = \text{pmin} - \text{pg} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{pg} - \text{pmax} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{pg} - \text{pmax} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, ngen)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, ngen)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.qg_bound_residual"><code class="name flex">
<span>def <span class="ident">qg_bound_residual</span></span>(<span>self, qg:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the reactive power generation bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = \text{qmin} - \text{qg} </span><script type="math/tex; mode=display"> g_{\text{lower}} = \text{qmin} - \text{qg} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{qg} - \text{qmax} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{qg} - \text{qmax} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>qg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, ngen)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, ngen)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.thermal_residual"><code class="name flex">
<span>def <span class="ident">thermal_residual</span></span>(<span>self, pf:Â torch.Tensor, pt:Â torch.Tensor, qf:Â torch.Tensor, qt:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the thermal limit residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{thrm}_1} = \text{pf}^2 + \text{qf}^2 - \text{s1max} </span><script type="math/tex; mode=display"> g_{\text{thrm}_1} = \text{pf}^2 + \text{qf}^2 - \text{s1max} </script></span>
<span><span class="MathJax_Preview"> g_{\text{thrm}_2} = \text{pt}^2 + \text{qt}^2 - \text{s2max} </span><script type="math/tex; mode=display"> g_{\text{thrm}_2} = \text{pt}^2 + \text{qt}^2 - \text{s2max} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power flow from bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>pt</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power flow to bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>qf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power flow from bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>qt</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Reactive power flow to bus per branch. (batch_size, nbranch)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Thermal limit residual for from branch. (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Thermal limit residual for to branch. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.ACPViolation.vm_bound_residual"><code class="name flex">
<span>def <span class="ident">vm_bound_residual</span></span>(<span>self, vm:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the voltage magnitude bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = \text{vmin} - \text{vm} </span><script type="math/tex; mode=display"> g_{\text{lower}} = \text{vmin} - \text{vm} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{vm} - \text{vmax} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{vm} - \text{vmax} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vm</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage magnitude per bus. (batch_size, nbus)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, nbus)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, nbus)</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.violation.OPFViolation" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation">OPFViolation</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.violation.OPFViolation.adjacency_matrix" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.adjacency_matrix">adjacency_matrix</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_from_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_incidence">branch_from_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_from_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_to_bus">branch_from_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_incidence">branch_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_to_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_incidence">branch_to_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_to_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_to_bus">branch_to_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.forward" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation.forward">forward</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.gen_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.gen_to_bus">gen_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.generator_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.generator_incidence">generator_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.load_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.load_incidence">load_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.load_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.load_to_bus">load_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.violation_shapes" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation.violation_shapes">violation_shapes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.BoundRepair"><code class="flex name class">
<span>class <span class="ident">BoundRepair</span></span>
<span>(</span><span>xmin:Â Optional[torch.Tensor], xmax:Â Optional[torch.Tensor], method:Â strÂ =Â 'relu', sanity_check:Â boolÂ =Â True, memory_efficient:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>An activation function that clips the output to a given range.</p>
<p>Initializes the BoundRepair module.</p>
<p>If both <code>xmin</code> and <code>xmax</code> are None, per-sample bounds must be provided as input to the forward method.
In this case <code>memory_efficient</code> is ignored (it is set to 2 regardless).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bounds for clipping.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bounds for clipping.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>The method to use for clipping. One of ["relu", "sigmoid", "clamp", "softplus", "tanh", "none"].</dd>
<dt><strong><code>sanity_check</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, performs sanity checks on the input.</dd>
<dt><strong><code>memory_efficient</code></strong> :&ensp;<code>int</code></dt>
<dd>0: pre-compute masks and pre-index bounds, 1: pre-compute masks, 2: do not pre-compute anything</dd>
</dl></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/layers/bound_repair.py#L7-L363" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ml4opf.BoundRepair.SUPPORTED_METHODS"><code class="name">var <span class="ident">SUPPORTED_METHODS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ml4opf.BoundRepair.double_relu"><code class="name flex">
<span>def <span class="ident">double_relu</span></span>(<span>x:Â torch.Tensor, xmin:Â torch.Tensor, xmax:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>ReLU bound repair function for double-sided bounds.</p>
<p><span><span class="MathJax_Preview"> \text{relu}(x - \underline{x}) - \text{relu}(x - \overline{x}) + \underline{x} </span><script type="math/tex; mode=display"> \text{relu}(x - \underline{x}) - \text{relu}(x - \overline{x}) + \underline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bound.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.double_sigmoid"><code class="name flex">
<span>def <span class="ident">double_sigmoid</span></span>(<span>x:Â torch.Tensor, xmin:Â torch.Tensor, xmax:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Sigmoid bound repair function for double-sided bounds.</p>
<p><span><span class="MathJax_Preview"> \text{sigmoid}(x) \cdot (\overline{x} - \underline{x}) + \underline{x} </span><script type="math/tex; mode=display"> \text{sigmoid}(x) \cdot (\overline{x} - \underline{x}) + \underline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bound.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.double_softplus"><code class="name flex">
<span>def <span class="ident">double_softplus</span></span>(<span>x:Â torch.Tensor, xmin:Â torch.Tensor, xmax:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Softplus bound repair function for double-sided bounds.</p>
<p><span><span class="MathJax_Preview"> \text{softplus}(x - \underline{x}) - \text{softplus}(x - \overline{x}) + \underline{x} </span><script type="math/tex; mode=display"> \text{softplus}(x - \underline{x}) - \text{softplus}(x - \overline{x}) + \underline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bound.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.double_tanh"><code class="name flex">
<span>def <span class="ident">double_tanh</span></span>(<span>x:Â torch.Tensor, xmin:Â torch.Tensor, xmax:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Tanh bound repair function for double-sided bounds.</p>
<p><span><span class="MathJax_Preview"> (\frac{1}{2} \tanh(x) + \frac{1}{2}) \cdot (\overline{x} - \underline{x}) + \underline{x} </span><script type="math/tex; mode=display"> (\frac{1}{2} \tanh(x) + \frac{1}{2}) \cdot (\overline{x} - \underline{x}) + \underline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bound.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.lower_relu"><code class="name flex">
<span>def <span class="ident">lower_relu</span></span>(<span>x:Â torch.Tensor, xmin:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>ReLU bound repair function for lower bounds.</p>
<p><span><span class="MathJax_Preview"> \text{relu}(x - \underline{x}) + \underline{x} </span><script type="math/tex; mode=display"> \text{relu}(x - \underline{x}) + \underline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.lower_softplus"><code class="name flex">
<span>def <span class="ident">lower_softplus</span></span>(<span>x:Â torch.Tensor, xmin:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Softplus bound repair function for lower bounds.</p>
<p><span><span class="MathJax_Preview"> \text{softplus}(x - \underline{x}) + \underline{x} </span><script type="math/tex; mode=display"> \text{softplus}(x - \underline{x}) + \underline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Lower bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.upper_relu"><code class="name flex">
<span>def <span class="ident">upper_relu</span></span>(<span>x:Â torch.Tensor, xmax:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>ReLU bound repair function for upper bounds.</p>
<p><span><span class="MathJax_Preview"> -\text{relu}(\overline{x} - x) + \overline{x} </span><script type="math/tex; mode=display"> -\text{relu}(\overline{x} - x) + \overline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.upper_softplus"><code class="name flex">
<span>def <span class="ident">upper_softplus</span></span>(<span>x:Â torch.Tensor, xmax:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Softplus bound repair function for upper bounds.</p>
<p><span><span class="MathJax_Preview"> -\text{softplus}(\overline{x} - x) + \overline{x} </span><script type="math/tex; mode=display"> -\text{softplus}(\overline{x} - x) + \overline{x} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Upper bound.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.BoundRepair.clamp"><code class="name flex">
<span>def <span class="ident">clamp</span></span>(<span>self, x:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Bound repair function that uses <code>torch.clamp</code>.</p>
<p><span><span class="MathJax_Preview"> \text{clamp}(x, \underline{x}, \overline{x}) </span><script type="math/tex; mode=display"> \text{clamp}(x, \underline{x}, \overline{x}) </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, x:Â torch.Tensor, xmin:Â Optional[torch.Tensor]Â =Â None, xmax:Â Optional[torch.Tensor]Â =Â None) â€‘>Â Callable[...,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the bound clipping function to the input.</p></div>
</dd>
<dt id="ml4opf.BoundRepair.load_state_dict"><code class="name flex">
<span>def <span class="ident">load_state_dict</span></span>(<span>self, state_dict:Â dict, strict:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the state dictionary and re-initializes the pre-computed quantities.</p></div>
</dd>
<dt id="ml4opf.BoundRepair.none"><code class="name flex">
<span>def <span class="ident">none</span></span>(<span>self, x:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>no-op, just return x</p></div>
</dd>
<dt id="ml4opf.BoundRepair.preprocess_bounds"><code class="name flex">
<span>def <span class="ident">preprocess_bounds</span></span>(<span>self, memory_efficient:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Pre-computes masks and pre-indexes bounds depending on <code>memory_efficient</code> level.</p>
<h2 id="args">Args</h2>
<p>memory_efficient (int):</p>
<p><code>0</code>: (fastest, most memory) pre-compute masks and index bounds</p>
<p><code>1</code>: pre-compute masks only</p>
<p><code>2</code>: (slowest, least memory) do not pre-compute anything</p></div>
</dd>
<dt id="ml4opf.BoundRepair.relu"><code class="name flex">
<span>def <span class="ident">relu</span></span>(<span>self, x:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the ReLU-based bound repair functions to the input, supporting any combination of single- or double-sided bounds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.sigmoid"><code class="name flex">
<span>def <span class="ident">sigmoid</span></span>(<span>self, x:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the sigmoid bound repair function to the input, supporting only unbounded or double-sided bounds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.softplus"><code class="name flex">
<span>def <span class="ident">softplus</span></span>(<span>self, x:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the softplus bound-clipping function to the input, supporting any combination of single- or double-sided bounds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
<dt id="ml4opf.BoundRepair.tanh"><code class="name flex">
<span>def <span class="ident">tanh</span></span>(<span>self, x:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the tanh bound-clipping function to the input, supporting only unbounded or double-sided bounds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Output tensor satisfying the bounds.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.DCPModel"><code class="flex name class">
<span>class <span class="ident">DCPModel</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.OPFModel" href="#ml4opf.OPFModel">OPFModel</a></code> for DCPPowerModel/DCOPF</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/dcp/model.py#L11-L92" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.model.OPFModel" href="formulations/model.html#ml4opf.formulations.model.OPFModel">OPFModel</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.dcp.model.PerfectDCPModel" href="formulations/dcp/model.html#ml4opf.formulations.dcp.model.PerfectDCPModel">PerfectDCPModel</a></li>
<li><a title="ml4opf.models.basic_nn.dcp_basic_nn.DCPBasicNeuralNet" href="models/basic_nn/dcp_basic_nn.html#ml4opf.models.basic_nn.dcp_basic_nn.DCPBasicNeuralNet">DCPBasicNeuralNet</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ml4opf.DCPModel.problem"><code class="name">var <span class="ident">problem</span> :Â <a title="ml4opf.formulations.dcp.problem.DCPProblem" href="formulations/dcp/problem.html#ml4opf.formulations.dcp.problem.DCPProblem">DCPProblem</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ml4opf.DCPModel.violation"><code class="name">var <span class="ident">violation</span> :Â <a title="ml4opf.formulations.dcp.violation.DCPViolation" href="formulations/dcp/violation.html#ml4opf.formulations.dcp.violation.DCPViolation">DCPViolation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.DCPModel.evaluate_model"><code class="name flex">
<span>def <span class="ident">evaluate_model</span></span>(<span>self, reduction:Â Optional[str]Â =Â None, inner_reduction:Â Optional[str]Â =Â None) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the model on the test data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reduction</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reduction method for the metrics. Defaults to None. Must be one of "mean", "sum","max", "none".
If specified, each value in the returned dictionary will be a scalar. Otherwise, they are arrays of shape (n_test_samples,)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>
<p>Dictionary containing Tensor metrics of the model's performance.</p>
<p><code>pg_lower</code>: Generator lower bound violation.</p>
<p><code>pg_upper</code>: Generator upper bound violation.</p>
<p><code>dva_lower</code>: Angle difference limit lower bound violation.</p>
<p><code>dva_upper</code>: Angle difference limit upper bound violation.</p>
<p><code>pf_lower</code>: Flow limit lower bound violation.</p>
<p><code>pf_upper</code>: Flow limit upper bound violation.</p>
<p><code>p_balance</code>: Power balance violation.</p>
<p><code>pg_gap</code>: Mean absolute error of the real power generation.</p>
<p><code>va_gap</code>: Mean absolute error of the voltage angle. (if not bus-wise and va not in predictions, skipped)</p>
<p><code>pf_gap</code>: Mean absolute error of the real power flow.</p>
<p><code>obj_mape</code>: Mean absolute percent error of the objective value.</p>
</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPModel.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, pd:Â torch.Tensor) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the DCOPF primal solution for a given set of loads.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power demand per load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>
<p>Dictionary containing the predicted primal solution.</p>
<p><code>pg</code>: Active power generation per generator or per bus.</p>
<p><code>va</code>: Voltage angle per bus.</p>
</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.model.OPFModel" href="formulations/model.html#ml4opf.formulations.model.OPFModel">OPFModel</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.model.OPFModel.load_from_checkpoint" href="formulations/model.html#ml4opf.formulations.model.OPFModel.load_from_checkpoint">load_from_checkpoint</a></code></li>
<li><code><a title="ml4opf.formulations.model.OPFModel.save_checkpoint" href="formulations/model.html#ml4opf.formulations.model.OPFModel.save_checkpoint">save_checkpoint</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.DCPProblem"><code class="flex name class">
<span>class <span class="ident">DCPProblem</span></span>
<span>(</span><span>data_directory:Â str, case_name:Â str, dataset_name:Â strÂ =Â 'DCOPF', **parse_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.OPFProblem" href="#ml4opf.OPFProblem">OPFProblem</a></code> for DCPPowerModel/DCOPF</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/dcp/problem.py#L5-L64" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.problem.OPFProblem" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem">OPFProblem</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ml4opf.DCPProblem.default_combos"><code class="name">prop <span class="ident">default_combos</span> :Â dict[str,Â list[str]]</code></dt>
<dd>
<div class="desc"><p>Default combos for DCOPF:</p>
<ul>
<li>
<p>input: pd</p>
</li>
<li>
<p>target: pg, va</p>
</li>
</ul></div>
</dd>
<dt id="ml4opf.DCPProblem.default_order"><code class="name">prop <span class="ident">default_order</span> :Â list[str]</code></dt>
<dd>
<div class="desc"><p>Default order for DCOPF. input, target</p></div>
</dd>
<dt id="ml4opf.DCPProblem.feasibility_check"><code class="name">prop <span class="ident">feasibility_check</span> :Â dict[str,Â str]</code></dt>
<dd>
<div class="desc"><p>Default feasibility check for DCOPF:</p>
<ul>
<li>
<p>termination_status: "OPTIMAL"</p>
</li>
<li>
<p>primal_status: "FEASIBLE_POINT"</p>
</li>
<li>
<p>dual_status: "FEASIBLE_POINT"</p>
</li>
</ul></div>
</dd>
<dt id="ml4opf.DCPProblem.violation"><code class="name">prop <span class="ident">violation</span> :Â <a title="ml4opf.formulations.dcp.violation.DCPViolation" href="formulations/dcp/violation.html#ml4opf.formulations.dcp.violation.DCPViolation">DCPViolation</a></code></dt>
<dd>
<div class="desc"><p>OPFViolation object for DCOPF constraint calculations.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.problem.OPFProblem" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem">OPFProblem</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.problem.OPFProblem.default_parse_only" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.default_parse_only">default_parse_only</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.make_dataset" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.make_dataset">make_dataset</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.parse" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.parse">parse</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.slice_batch" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.slice_batch">slice_batch</a></code></li>
<li><code><a title="ml4opf.formulations.problem.OPFProblem.slice_tensor" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem.slice_tensor">slice_tensor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.DCPViolation"><code class="flex name class">
<span>class <span class="ident">DCPViolation</span></span>
<span>(</span><span>json_data:Â dict[str,Â typing.Union[bool,Â int,Â float,Â dict[str,Â torch.Tensor]]])</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code> for DCPPowerModel/DCOPF</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/dcp/violation.py#L13-L271" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.violation.OPFViolation" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation">OPFViolation</a></li>
<li><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin">IncidenceMixin</a></li>
<li>torch.nn.modules.module.Module</li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ml4opf.DCPViolation.nrate_a"><code class="name">prop <span class="ident">nrate_a</span> :Â torch.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.DCPViolation.angle_difference"><code class="name flex">
<span>def <span class="ident">angle_difference</span></span>(<span>self, va:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle differences per branch given the voltage angles per bus.</p>
<p>The branch indices are assumed to be constant for the batch, matching the reference case.</p>
<p><span><span class="MathJax_Preview">
\text{dva} = \boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}
</span><script type="math/tex; mode=display">
\text{dva} = \boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>va</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angles per bus ( <span><span class="MathJax_Preview">\boldsymbol{\theta}</span><script type="math/tex">\boldsymbol{\theta}</script></span> ). (batch_size, nbus)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Angle differences per branch. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.balance_residual"><code class="name flex">
<span>def <span class="ident">balance_residual</span></span>(<span>self, pd:Â torch.Tensor, pg:Â torch.Tensor, pf:Â torch.Tensor, embed_method:Â strÂ =Â 'pad', clamp:Â boolÂ =Â True) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute power balance residual.</p>
<p><span><span class="MathJax_Preview">
\text{g_balance} = \text{pg_bus} - \text{pd_bus} - \text{gs_bus} - \text{pf_bus} - \text{pt_bus}
</span><script type="math/tex; mode=display">
\text{g_balance} = \text{pg_bus} - \text{pd_bus} - \text{gs_bus} - \text{pf_bus} - \text{pt_bus}
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power demand per bus. (batch_size, nbus)</dd>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>pf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power flow per branch. (batch_size, nbranch)</dd>
<dt><strong><code>embed_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Embedding method to convert component-wise values to bus-wise &ndash; one of "pad", "dense_matrix", or "matrix". Defaults to "pad".</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp to extract only violations. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Power balance residual. (batch_size, nbus)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.calc_violations"><code class="name flex">
<span>def <span class="ident">calc_violations</span></span>(<span>self, pd:Â torch.Tensor, pg:Â torch.Tensor, va:Â torch.Tensor, pf:Â Optional[torch.Tensor]Â =Â None, reduction:Â strÂ =Â 'mean', clamp:Â boolÂ =Â True, embed_method:Â strÂ =Â 'pad') â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute all DCOPF violations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pd</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power demand per bus. (batch_size, nbus)</dd>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>va</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angles per bus. (batch_size, nbus)</dd>
<dt><strong><code>pf</code></strong> :&ensp;<code>Tensor</code>, optional</dt>
<dd>Power flow per branch. Defaults to None.</dd>
<dt><strong><code>reduction</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reduction method. Defaults to "mean".</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp to extract only violations. Defaults to True.</dd>
<dt><strong><code>embed_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Embedding method to convert component-wise values to bus-wise &ndash; one of "pad", "dense_matrix", or "matrix". Defaults to "pad".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>Dictionary of all violations:</dd>
</dl>
<ul>
<li>
<p>"pg_lower": Lower bound violation of power generation. (batch_size, ngen)</p>
</li>
<li>
<p>"pg_upper": Upper bound violation of power generation. (batch_size, ngen)</p>
</li>
<li>
<p>"dva_lower": Lower bound violation of voltage angle difference. (batch_size, nbranch)</p>
</li>
<li>
<p>"dva_upper": Upper bound violation of voltage angle difference. (batch_size, nbranch)</p>
</li>
<li>
<p>"pf_lower": Lower bound violation of power flow. (batch_size, nbranch)</p>
</li>
<li>
<p>"pf_upper": Upper bound violation of power flow. (batch_size, nbranch)</p>
</li>
<li>
<p>"p_balance": Power balance violation. (batch_size, nbus)</p>
</li>
<li>
<p>"ohm": Ohm's law violation. (batch_size, nbranch)</p>
</li>
</ul></div>
</dd>
<dt id="ml4opf.DCPViolation.dva_bound_residual"><code class="name flex">
<span>def <span class="ident">dva_bound_residual</span></span>(<span>self, dva:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the voltage angle difference bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = \text{angmin} - \text{dva} </span><script type="math/tex; mode=display"> g_{\text{lower}} = \text{angmin} - \text{dva} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{dva} - \text{angmax} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{dva} - \text{angmax} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dva</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angle differences per branch. (batch_size, nbranch)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.objective"><code class="name flex">
<span>def <span class="ident">objective</span></span>(<span>self, pg:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute DCOPF objective function.</p>
<p>Cost is assumed to be constant for the batch, matching the reference case.</p>
<p><span><span class="MathJax_Preview">
\text{objective} = \sum_i^n \text{cost}_{2,i} + \text{cost}_{1,i} \cdot \text{pg}_i
</span><script type="math/tex; mode=display">
\text{objective} = \sum_i^n \text{cost}_{2,i} + \text{cost}_{1,i} \cdot \text{pg}_i
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power generation per generator. (batch_size, ngen)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Objective function value. (batch_size, 1)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.ohm_residual"><code class="name flex">
<span>def <span class="ident">ohm_residual</span></span>(<span>self, pf:Â torch.Tensor, dva:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute Ohm's law violation.</p>
<p><span><span class="MathJax_Preview">
\text{g_ohm} = - b \cdot \text{dva} - \text{pf}
</span><script type="math/tex; mode=display">
\text{g_ohm} = - b \cdot \text{dva} - \text{pf}
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power flow per branch. (batch_size, nbranch)</dd>
<dt><strong><code>dva</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angle differences per branch. (batch_size, nbranch)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp to extract only violations. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Ohm's law violation. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.pf_bound_residual"><code class="name flex">
<span>def <span class="ident">pf_bound_residual</span></span>(<span>self, pf:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the power flow bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = -\text{rate_a} - \text{pf} </span><script type="math/tex; mode=display"> g_{\text{lower}} = -\text{rate_a} - \text{pf} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{pf} - \text{rate_a} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{pf} - \text{rate_a} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pf</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Power flow per branch. (batch_size, nbranch)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, nbranch)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.pf_from_va"><code class="name flex">
<span>def <span class="ident">pf_from_va</span></span>(<span>self, va:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute power flow given voltage angles.</p>
<p><span><span class="MathJax_Preview"> \mathbf{p}_f = -\text{b} \cdot (\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) </span><script type="math/tex; mode=display"> \mathbf{p}_f = -\text{b} \cdot (\boldsymbol{\theta}_{f} - \boldsymbol{\theta}_{t}) </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>va</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Voltage angles per bus ( <span><span class="MathJax_Preview">\boldsymbol{\theta}</span><script type="math/tex">\boldsymbol{\theta}</script></span> ). (batch_size, nbus)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Power flow per branch ( <span><span class="MathJax_Preview">\mathbf{p}_f</span><script type="math/tex">\mathbf{p}_f</script></span> ). (batch_size, nbranch)</dd>
</dl></div>
</dd>
<dt id="ml4opf.DCPViolation.pg_bound_residual"><code class="name flex">
<span>def <span class="ident">pg_bound_residual</span></span>(<span>self, pg:Â torch.Tensor, clamp:Â boolÂ =Â False) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the power generation bound residual.</p>
<p><span><span class="MathJax_Preview"> g_{\text{lower}} = \text{pmin} - \text{pg} </span><script type="math/tex; mode=display"> g_{\text{lower}} = \text{pmin} - \text{pg} </script></span>
<span><span class="MathJax_Preview"> g_{\text{upper}} = \text{pg} - \text{pmax} </span><script type="math/tex; mode=display"> g_{\text{upper}} = \text{pg} - \text{pmax} </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pg</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Active power generation per generator. (batch_size, ngen)</dd>
<dt><strong><code>clamp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Clamp the residual to be non-negative (extract violations). Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tensor</code></dt>
<dd>Lower bound residual. (batch_size, ngen)</dd>
<dt><code>Tensor</code></dt>
<dd>Upper bound residual. (batch_size, ngen)</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.violation.OPFViolation" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation">OPFViolation</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.violation.OPFViolation.adjacency_matrix" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.adjacency_matrix">adjacency_matrix</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_from_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_incidence">branch_from_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_from_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_to_bus">branch_from_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_incidence">branch_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_to_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_incidence">branch_to_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.branch_to_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_to_bus">branch_to_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.forward" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation.forward">forward</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.gen_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.gen_to_bus">gen_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.generator_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.generator_incidence">generator_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.load_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.load_incidence">load_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.load_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.load_to_bus">load_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.violation.OPFViolation.violation_shapes" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation.violation_shapes">violation_shapes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.H5Parser"><code class="flex name class">
<span>class <span class="ident">H5Parser</span></span>
<span>(</span><span>input_path:Â Union[str,Â pathlib.Path], data_path:Â Union[str,Â pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"><p>Parser for HDF5 files generated by AI4OPT/OPFGenerator.</p>
<p>Initialize the parser by validating and setting the path.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/parsers/parse_h5.py#L13-L415" class="git-link">Browse git</a></div>
<h3>Static methods</h3>
<dl>
<dt id="ml4opf.H5Parser.apply_mask"><code class="name flex">
<span>def <span class="ident">apply_mask</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], mask:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a mask to the data dictionary in-place.</p></div>
</dd>
<dt id="ml4opf.H5Parser.convert_to_float32"><code class="name flex">
<span>def <span class="ident">convert_to_float32</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]])</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all float64 data to float32 in-place.</p></div>
</dd>
<dt id="ml4opf.H5Parser.extract_test_set"><code class="name flex">
<span>def <span class="ident">extract_test_set</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], test_set_size:Â intÂ =Â 5000, seed:Â Optional[int]Â =Â 42) â€‘>Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a test set from the data dictionary in-place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dat</code></strong> :&ensp;<code>ParsedHDF5Dict</code></dt>
<dd>Dictionary of parsed data from <code>.parse()</code>.</dd>
<dt><strong><code>test_set_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of the test set. Defaults to 5000.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>Optional[int]</code>, optional</dt>
<dd>Seed for random number generator. Defaults to 42.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ParsedHDF5Dict</code></dt>
<dd>Dictionary of test portion of the data.</dd>
</dl>
<p>After this function is called, the <code>dat</code> dictionary will contain
only training data (to be split downstream into training / validation)
and the returned dictionary will contain only test data.</p></div>
</dd>
<dt id="ml4opf.H5Parser.filter_by_total_load"><code class="name flex">
<span>def <span class="ident">filter_by_total_load</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], bounds:Â tuple[typing.Optional[float],Â typing.Optional[float]]Â =Â (None, None))</span>
</code></dt>
<dd>
<div class="desc"><p>Filter data by total load.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dat</code></strong> :&ensp;<code>ParsedHDF5Dict</code></dt>
<dd>Dictionary of parsed data from <code>.parse()</code>.</dd>
<dt><strong><code>upper</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Upper bound on total load. Defaults to None.</dd>
<dt><strong><code>lower</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Lower bound on total load. Defaults to None.</dd>
</dl></div>
</dd>
<dt id="ml4opf.H5Parser.get_n_samples"><code class="name flex">
<span>def <span class="ident">get_n_samples</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], sanity_check:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ml4opf.H5Parser.keep_n_samples"><code class="name flex">
<span>def <span class="ident">keep_n_samples</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], n:Â int, seed:Â Optional[int]Â =Â 42) â€‘>Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]]</span>
</code></dt>
<dd>
<div class="desc"><p>Keep only <code>n</code> samples from the data dictionary in-place.</p></div>
</dd>
<dt id="ml4opf.H5Parser.make_tree"><code class="name flex">
<span>def <span class="ident">make_tree</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], delimiter:Â strÂ =Â '/')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a flat dictionary to a tree.
Note that the keys of <code>dat</code> must have a tree structure where data is only at the leaves.
Assumes keys are delimited by "/", i.e. "solution/primal/pg".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dat</code></strong> :&ensp;<code>dict</code></dt>
<dd>Flat dictionary of data.</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Delimiter to use for splitting keys. Defaults to "/".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Tree dictionary of data from <code>dat</code>.</dd>
</dl></div>
</dd>
<dt id="ml4opf.H5Parser.remove_infeasible_points"><code class="name flex">
<span>def <span class="ident">remove_infeasible_points</span></span>(<span>dat:Â dict[str,Â typing.Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]], feasible_by:Â dict[str,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>Remove infeasible points from the data dictionary in-place</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dat</code></strong> :&ensp;<code>ParsedHDF5Dict</code></dt>
<dd>Dictionary of parsed data from .parse().</dd>
<dt><strong><code>feasible_by</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>Dictionary of key-value pairs to filter by.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.H5Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, parse_only:Â Optional[list[str]]Â =Â None, train_set_size:Â Optional[int]Â =Â None, feasible_by:Â Optional[dict[str,Â str]]Â =Â None, make_test_set:Â boolÂ =Â False, test_set_size:Â intÂ =Â 5000, total_load_range:Â tuple[typing.Optional[float],Â typing.Optional[float]]Â =Â (None, None), convert_to_float32:Â boolÂ =Â True, sanity_check:Â boolÂ =Â True) â€‘>Â Union[dict[str,Â Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]],Â tuple[dict[str,Â Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]],Â dict[str,Â Union[torch.Tensor,Â numpy.ndarray,Â numpy.str_]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the HDF5 file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parse_only</code></strong> :&ensp;<code>list[str]</code>, optional</dt>
<dd>A list of strings of the form <code>solution/primal/pg</code> where <code>solution</code> is the group, <code>primal</code> is the subgroup, and <code>pg</code> is the dataset from the HDF5 file. Defaults to None.</dd>
<dt><strong><code>train_set_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of samples to keep, not including the test set size. Defaults to None.</dd>
<dt><strong><code>feasible_by</code></strong> :&ensp;<code>dict[str, str]</code>, optional</dt>
<dd>A dictionary of key-value pairs to filter by. Defaults to None.</dd>
<dt><strong><code>make_test_set</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, return a tuple of two dictionaries (training set, test set). Defaults to False.</dd>
<dt><strong><code>test_set_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of points to use for the test set. Defaults to 5000.</dd>
<dt><strong><code>total_load_range</code></strong> :&ensp;<code>tuple[Optional[float], Optional[float]]</code>, optional</dt>
<dd>Range of total load values to use. Defaults to (None, None).</dd>
<dt><strong><code>convert_to_float32</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, convert all float64 data to torch.float32. Defaults to True.</dd>
<dt><strong><code>sanity_check</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, perform sanity checks on the data. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Flattened dictionary of HDF5 data with PyTorch tensors for numerical data and NumPy arrays for string/object data.</dd>
</dl>
<p>If <code>make_test_set</code> is True, then this function will return a tuple of two dictionaries. The first dictionary is the
training set and the second dictionary is the test set. The test set is a random 10% sample of the training set.</p>
<p>This parser will return a single-level dictionary where the keys are in the form
of <code>solution/primal/pg</code> where <code>solution</code> is the group, <code>primal</code> is the subgroup,
and <code>pg</code> is the dataset from the HDF5 file. The values are PyTorch tensors. This
parser uses <code>h5py.File.visititems</code> to iterate over the HDF5 file quickly.</p></div>
</dd>
<dt id="ml4opf.H5Parser.validate_path"><code class="name flex">
<span>def <span class="ident">validate_path</span></span>(<span>self, path:Â Union[str,Â pathlib.Path]) â€‘>Â pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the path to the HDF5 file.</p></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.HyperSimplexRepair"><code class="flex name class">
<span>class <span class="ident">HyperSimplexRepair</span></span>
<span>(</span><span>lb:Â Optional[torch.Tensor]Â =Â None, ub:Â Optional[torch.Tensor]Â =Â None, sanity_check:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Recovery for hyper simplex constraint <span><span class="MathJax_Preview">\{ x_i \in [l_i, u_i] \,\vert\, \sum x = b \}</span><script type="math/tex">\{ x_i \in [l_i, u_i] \,\vert\, \sum x = b \}</script></span>.</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/layers/hypersimplex_repair.py#L7-L78" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ml4opf.HyperSimplexRepair.proportional_projection"><code class="name flex">
<span>def <span class="ident">proportional_projection</span></span>(<span>x:Â torch.Tensor, lb:Â torch.Tensor, ub:Â torch.Tensor, b:Â torch.Tensor)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.HyperSimplexRepair.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, x_:Â torch.Tensor, b:Â torch.Tensor) â€‘>Â Callable[...,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.JSONParser"><code class="flex name class">
<span>class <span class="ident">JSONParser</span></span>
<span>(</span><span>path:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides PyTorch tensors given a path to a PowerModels Network Data JSON file.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/parsers/parse_json.py#L10-L387" class="git-link">Browse git</a></div>
<h3>Static methods</h3>
<dl>
<dt id="ml4opf.JSONParser.pad_to_dense"><code class="name flex">
<span>def <span class="ident">pad_to_dense</span></span>(<span>array, padval, dtype=builtins.int)</span>
</code></dt>
<dd>
<div class="desc"><p>from <a href="https://codereview.stackexchange.com/questions/222623/pad-a-ragged-multidimensional-array-to-rectangular-shape">https://codereview.stackexchange.com/questions/222623/pad-a-ragged-multidimensional-array-to-rectangular-shape</a></p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.JSONParser.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Open the JSON file, supporting gzip and bz2 compression based on the file suffix.</p></div>
</dd>
<dt id="ml4opf.JSONParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, model_type:Â Union[str,Â Sequence[str]]Â =Â [], sanity_check:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the JSON file from OPFGenerator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code>Union[str, Sequence[str]]</code></dt>
<dd>The reference solutions to save. Default: [] (no reference solutions saved.)</dd>
<dt><strong><code>sanity_check</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to sanity check the data. Default: True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the parsed data.</dd>
</dl>
<p>In the JSON file, the data is stored by each individual component.
So to get generator 1's upper bound on active generation, you'd look at:
raw_json['data']['gen']['1']['pmax'] and get a float.</p>
<p>In the parsed version, we aggregate each of the components attributes into torch.Tensor arrays.
So to get generator 1's upper bound on active generation, you'd look at:
dat['gen']['pmax'][0] and get a float.
Note that the index is 0-based and an integer, not 1-based and a string.</p>
<p>To access the reference solution, pass a model_type (or multiple) and then use it as the key.</p></div>
</dd>
<dt id="ml4opf.JSONParser.validate_path"><code class="name flex">
<span>def <span class="ident">validate_path</span></span>(<span>self, path:Â str) â€‘>Â pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the path to the JSON file.</p></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.LDFLoss"><code class="flex name class">
<span>class <span class="ident">LDFLoss</span></span>
<span>(</span><span>v:Â <a title="ml4opf.formulations.violation.OPFViolation" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation">OPFViolation</a>, step_size:Â float, kickin:Â int, update_freq:Â int, divide_by_counter:Â boolÂ =Â True, exclude_keys:Â Union[str,Â list[str],Â ForwardRef(None)]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>LDFLoss implements the Lagrangian Dual Framework.
params should have: <code>step_size</code>, <code>kickin</code>, <code>update_freq</code>, <code>divide_by_counter</code>, and optionally <code>exclude_keys</code>.</p>
<p><code>exclude_keys</code> is either None to use all violations, "all" to skip all violations, or a list of keys to skip specific violations.</p>
<p>Initialize LDFLoss module.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/loss_functions/ldf.py#L11-L152" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.LDFLoss.end_epoch"><code class="name flex">
<span>def <span class="ident">end_epoch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call this method at the end of each epoch.</p></div>
</dd>
<dt id="ml4opf.LDFLoss.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, base_loss:Â torch.Tensor, exclude_keys:Â Union[str,Â list[str],Â ForwardRef(None)]Â =Â None, **calc_violation_inputs:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the LDF Loss for a batch of samples.</p></div>
</dd>
<dt id="ml4opf.LDFLoss.init_mults"><code class="name flex">
<span>def <span class="ident">init_mults</span></span>(<span>self, shapes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Î» and trackers to zeros.</p></div>
</dd>
<dt id="ml4opf.LDFLoss.reset_trackers"><code class="name flex">
<span>def <span class="ident">reset_trackers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the violation trackers to zeros.</p></div>
</dd>
<dt id="ml4opf.LDFLoss.start_epoch"><code class="name flex">
<span>def <span class="ident">start_epoch</span></span>(<span>self, epoch) â€‘>Â Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Call this method at the start of each epoch.</p></div>
</dd>
<dt id="ml4opf.LDFLoss.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the lagrangian dual multipliers (Î»)</p></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.OPFModel"><code class="flex name class">
<span>class <span class="ident">OPFModel</span></span>
</code></dt>
<dd>
<div class="desc"><p>An abstract base class for ACOPF models.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/model.py#L23-L70" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.acp.model.ACPModel" href="formulations/acp/model.html#ml4opf.formulations.acp.model.ACPModel">ACPModel</a></li>
<li><a title="ml4opf.formulations.dcp.model.DCPModel" href="formulations/dcp/model.html#ml4opf.formulations.dcp.model.DCPModel">DCPModel</a></li>
<li><a title="ml4opf.formulations.ed.model.EDModel" href="formulations/ed/model.html#ml4opf.formulations.ed.model.EDModel">EDModel</a></li>
<li><a title="ml4opf.models.basic_nn.basic_nn.BasicNeuralNet" href="models/basic_nn/basic_nn.html#ml4opf.models.basic_nn.basic_nn.BasicNeuralNet">BasicNeuralNet</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ml4opf.OPFModel.load_from_checkpoint"><code class="name flex">
<span>def <span class="ident">load_from_checkpoint</span></span>(<span>self, path_to_folder:Â str, problem:Â <a title="ml4opf.formulations.problem.OPFProblem" href="formulations/problem.html#ml4opf.formulations.problem.OPFProblem">OPFProblem</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the model's checkpoint from a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to load the checkpoint from.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.OPFModel.evaluate_model"><code class="name flex">
<span>def <span class="ident">evaluate_model</span></span>(<span>self, reduction:Â Optional[str]Â =Â None, inner_reduction:Â Optional[str]Â =Â None) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the model on the test data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reduction</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reduction method for the metrics. Defaults to None. Must be one of "mean", "sum", "none".
If specified, each value in the returned dictionary will be a scalar. Otherwise, they are arrays of shape (n_test_samples,)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>Dictionary containing Tensor metrics of the model's performance.</dd>
</dl></div>
</dd>
<dt id="ml4opf.OPFModel.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, *inputs:Â torch.Tensor) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the solution for a given set of inputs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*inputs</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Input tensors to the model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tensor]</code></dt>
<dd>Dictionary containing the solution.</dd>
</dl></div>
</dd>
<dt id="ml4opf.OPFModel.save_checkpoint"><code class="name flex">
<span>def <span class="ident">save_checkpoint</span></span>(<span>self, path_to_folder:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the model's checkpoint to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to save the checkpoint.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.OPFProblem"><code class="flex name class">
<span>class <span class="ident">OPFProblem</span></span>
<span>(</span><span>data_directory:Â str, case_name:Â str, dataset_name:Â str, **parse_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="opf-problem">OPF Problem</h1>
<p>This class parses the JSON/HDF5 files on initialization, providing a standard interface for accessing OPF data.</p>
<p>OPFProblem also includes methods for creating input/target tensors from the HDF5 data by concatenating keys,
though more complex datasets (e.g., for graph neural networks) can be created by accessing <code>train_data</code> and <code>json_data</code> directly.</p>
<p>By default, initializing OPFProblem will parse the HDF5/JSON files, remove infeasible samples, and set aside 5000 samples for testing.
The test data can be accessed via <code>test_data</code> - <code>train_data</code> will only contain the training data. Models should split the training data into
training/validation sets themselves downstream.</p>
<p>Attributes:</p>
<ul>
<li>
<p><code>path (Path)</code>: Path to the problem file folder</p>
</li>
<li>
<p><code>name (str)</code>: Name of the problem to use</p>
</li>
<li>
<p><code>train_data (dict)</code>: Dictionary of parsed HDF5 data. If <code>make_test_set</code> is True, this is only the training set.</p>
</li>
<li>
<p><code>test_data (dict)</code>: Dictionary of parsed HDF5 data for the test set. If <code>make_test_set</code> is False, this is None.</p>
</li>
<li>
<p><code>json_data (dict)</code>: Dictionary of parsed JSON data.</p>
</li>
<li>
<p><code>violation (<a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a>)</code>: OPFViolation object for computing constraint violations for this problem.</p>
</li>
</ul>
<p>Methods:</p>
<ul>
<li>
<p><code>parse</code>: Parse the JSON and HDF5 files for the problem</p>
</li>
<li>
<p><code>make_dataset</code>: Create input/target tensors by combining keys from the h5 data. Returns the TensorDataset and slices for extracting the original components.</p>
</li>
<li>
<p><code>slice_batch</code>: Extract the original components from a batch of data given the slices.</p>
</li>
<li>
<p><code>slice_tensor</code>: Extract the original components from a tensor given the slices.</p>
</li>
</ul></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/problem.py#L27-L252" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.acp.problem.ACPProblem" href="formulations/acp/problem.html#ml4opf.formulations.acp.problem.ACPProblem">ACPProblem</a></li>
<li><a title="ml4opf.formulations.dcp.problem.DCPProblem" href="formulations/dcp/problem.html#ml4opf.formulations.dcp.problem.DCPProblem">DCPProblem</a></li>
<li><a title="ml4opf.formulations.ed.problem.EDProblem" href="formulations/ed/problem.html#ml4opf.formulations.ed.problem.EDProblem">EDProblem</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ml4opf.OPFProblem.slice_batch"><code class="name flex">
<span>def <span class="ident">slice_batch</span></span>(<span>batch:Â tuple[torch.Tensor,Â ...], slices:Â list[dict[str,Â slice]])</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the batch tensors into the original tensors</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>batch</code></strong> :&ensp;<code>tuple[Tensor, &hellip;]</code></dt>
<dd>Batch of tensors from the TensorDataset</dd>
<dt><strong><code>slices</code></strong> :&ensp;<code>list[dict[str, slice]]</code></dt>
<dd>List of dictionaries of slices</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[dict[str, Tensor], &hellip;]</code></dt>
<dd>Sliced tensors</dd>
</dl></div>
</dd>
<dt id="ml4opf.OPFProblem.slice_tensor"><code class="name flex">
<span>def <span class="ident">slice_tensor</span></span>(<span>tensor:Â torch.Tensor, slices:Â dict[str,Â slice])</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the tensor into the original tensors</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code>Tensor</code></dt>
<dd>Tensor to slice</dd>
<dt><strong><code>slices</code></strong> :&ensp;<code>dict[str, slice]</code></dt>
<dd>Dictionary of slices</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>dict[str, Tensor]</code>: Sliced tensors</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ml4opf.OPFProblem.default_combos"><code class="name">prop <span class="ident">default_combos</span> :Â dict[str,Â list[str]]</code></dt>
<dd>
<div class="desc"><p>A dictionary where keys represent elements of the tuple
from the TensorDataset and values are keys of the train_data
dictionary which are concatenated.
Used by <code>make_dataset</code>.</p></div>
</dd>
<dt id="ml4opf.OPFProblem.default_order"><code class="name">prop <span class="ident">default_order</span> :Â list[str]</code></dt>
<dd>
<div class="desc"><p>The order of the keys in the default_combos dictionary.</p></div>
</dd>
<dt id="ml4opf.OPFProblem.default_parse_only"><code class="name">prop <span class="ident">default_parse_only</span> :Â list[str]</code></dt>
<dd>
<div class="desc"><p>The keys to parse from the HDF5 file.</p>
<p>By default, "meta/<em>", "primal/</em>", and "dual/*" are parsed from the data file
and the entire input file is parsed.</p></div>
</dd>
<dt id="ml4opf.OPFProblem.feasibility_check"><code class="name">prop <span class="ident">feasibility_check</span> :Â dict[str,Â str]</code></dt>
<dd>
<div class="desc"><p>Dictionary of keys and values to check feasibility of the problem.</p>
<p>Each key is checked to have the corresponding value. If any of them
does not match, the sample is removed from the dataset in <code>OPFGeneratorH5Parser</code>.
See ACOPFProblem.feasibility_check for an example.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.OPFProblem.make_dataset"><code class="name flex">
<span>def <span class="ident">make_dataset</span></span>(<span>self, combos:Â Optional[dict[str,Â list[str]]]Â =Â None, order:Â Optional[list[str]]Â =Â None, test_set:Â boolÂ =Â False, sanity_check:Â boolÂ =Â True) â€‘>Â tuple[dict[str,Â torch.Tensor],Â list[dict[str,Â slice]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Make a TensorDataset from self.train_data given the keys in combos and the order of the keys in order.</p></div>
</dd>
<dt id="ml4opf.OPFProblem.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, parse_only:Â Union[str,Â list[str],Â ForwardRef(None)]Â =Â 'default', train_set_size:Â Optional[int]Â =Â None, feasible_only:Â Union[bool,Â dict[str,Â str]]Â =Â True, make_test_set:Â boolÂ =Â True, test_set_size:Â intÂ =Â 5000, convert_to_float32:Â boolÂ =Â True, total_load_range:Â tuple[typing.Optional[float],Â typing.Optional[float]]Â =Â (None, None), sanity_check:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the JSON and HDF5 files for the problem</p></div>
</dd>
</dl>
</dd>
<dt id="ml4opf.OPFViolation"><code class="flex name class">
<span>class <span class="ident">OPFViolation</span></span>
<span>(</span><span>json_data:Â dict[str,Â typing.Union[bool,Â int,Â float,Â dict[str,Â torch.Tensor]]])</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code> class is where all the problem expressions (objective, constraints, etc.) are defined.
The classes provide a convenient interface for when the only varying quantity in the formulation
per sample is the load demand <code>pd</code>. If other quantities vary, the user should use the functional
interface at <code><a title="ml4opf.functional" href="functional/index.html">ml4opf.functional</a></code>.</p>
<p>When <code>clamp</code> is true, the values of g(x) are clamped to be non-negative and the values of h(x) are absolute-valued.
Otherwise the raw values are returned.</p>
<p><code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code> is a <code>torch.nn.Module</code>; all tensors used in computation are registered as non-persistent buffers.
To move the module to a different device, use <code>.to(device)</code> as you would with any other <code>nn.Module</code>.
Make sure that when you pass data to <code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code>, it is on the same device as <code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code>.</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/formulations/violation.py#L22-L114" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin">IncidenceMixin</a></li>
<li>torch.nn.modules.module.Module</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ml4opf.formulations.acp.violation.ACPViolation" href="formulations/acp/violation.html#ml4opf.formulations.acp.violation.ACPViolation">ACPViolation</a></li>
<li><a title="ml4opf.formulations.dcp.violation.DCPViolation" href="formulations/dcp/violation.html#ml4opf.formulations.dcp.violation.DCPViolation">DCPViolation</a></li>
<li><a title="ml4opf.formulations.ed.violation.EDViolation" href="formulations/ed/violation.html#ml4opf.formulations.ed.violation.EDViolation">EDViolation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ml4opf.OPFViolation.SUPPORTED_REDUCTIONS"><code class="name">var <span class="ident">SUPPORTED_REDUCTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ml4opf.OPFViolation.violation_shapes"><code class="name">prop <span class="ident">violation_shapes</span> :Â dict[str,Â int]</code></dt>
<dd>
<div class="desc"><p>Return the shapes of the violations returned by <code><a title="ml4opf.OPFViolation.calc_violations" href="#ml4opf.OPFViolation.calc_violations">OPFViolation.calc_violations()</a></code>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.OPFViolation.calc_violations"><code class="name flex">
<span>def <span class="ident">calc_violations</span></span>(<span>self, *args, reduction:Â strÂ =Â 'mean', clamp:Â boolÂ =Â True) â€‘>Â dict[str,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the violations of the constraints. Returns a dictionary of tensors.</p></div>
</dd>
<dt id="ml4opf.OPFViolation.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, *args, **kwargs) â€‘>Â Callable[...,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Pass-through for <code><a title="ml4opf.OPFViolation.calc_violations" href="#ml4opf.OPFViolation.calc_violations">OPFViolation.calc_violations()</a></code></p></div>
</dd>
<dt id="ml4opf.OPFViolation.objective"><code class="name flex">
<span>def <span class="ident">objective</span></span>(<span>self, *args) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the objective value for a batch of samples.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin">IncidenceMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.adjacency_matrix" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.adjacency_matrix">adjacency_matrix</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_incidence">branch_from_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_from_to_bus">branch_from_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_incidence">branch_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_incidence">branch_to_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.branch_to_to_bus">branch_to_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.gen_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.gen_to_bus">gen_to_bus</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.generator_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.generator_incidence">generator_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.load_incidence" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.load_incidence">load_incidence</a></code></li>
<li><code><a title="ml4opf.formulations.incidence_mixin.IncidenceMixin.load_to_bus" href="formulations/incidence_mixin.html#ml4opf.formulations.incidence_mixin.IncidenceMixin.load_to_bus">load_to_bus</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ml4opf.ObjectiveLoss"><code class="flex name class">
<span>class <span class="ident">ObjectiveLoss</span></span>
<span>(</span><span>v:Â <a title="ml4opf.formulations.violation.OPFViolation" href="formulations/violation.html#ml4opf.formulations.violation.OPFViolation">OPFViolation</a>, reduction:Â Optional[str]Â =Â 'mean')</span>
</code></dt>
<dd>
<div class="desc"><p>ObjectiveLoss is the original objective of the OPF.</p>
<p>It takes as input the same arguments as the corresponding formulation's
<code>compute_objective</code> method, and returns the objective value.</p>
<p>Initialize ObjectiveLoss module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code></dt>
<dd>OPFViolation module.</dd>
<dt><strong><code>reduction</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Reduction operation. Default: "mean".</dd>
</dl></div>
<div class="git-link-div"><a href="https://github.com/AI4OPT/ML4OPF/blob/0dd79a5b7ba7e1826bd70d110969c0a986455b93/ml4opf/loss_functions/objective.py#L9-L49" class="git-link">Browse git</a></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ml4opf.ObjectiveLoss.SUPPORTED_REDUCTIONS"><code class="name">var <span class="ident">SUPPORTED_REDUCTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4opf.ObjectiveLoss.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, *compute_objective_args, **compute_objective_kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the objective value for a batch of samples.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#ml4opf-machine-learning-for-opf">ML4OPF: Machine Learning for OPF</a></li>
<li><a href="#loading-data">Loading data</a></li>
<li><a href="#computing-residuals">Computing residuals</a></li>
<li><a href="#implementing-an-opfmodel">Implementing an OPFModel</a></li>
<li><a href="#using-repair-layers">Using repair layers</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="ml4opf.formulations" href="formulations/index.html">ml4opf.formulations</a></code></li>
<li><code><a title="ml4opf.functional" href="functional/index.html">ml4opf.functional</a></code></li>
<li><code><a title="ml4opf.layers" href="layers/index.html">ml4opf.layers</a></code></li>
<li><code><a title="ml4opf.loss_functions" href="loss_functions/index.html">ml4opf.loss_functions</a></code></li>
<li><code><a title="ml4opf.models" href="models/index.html">ml4opf.models</a></code></li>
<li><code><a title="ml4opf.parsers" href="parsers/index.html">ml4opf.parsers</a></code></li>
<li><code><a title="ml4opf.viz" href="viz/index.html">ml4opf.viz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ml4opf.ACPModel" href="#ml4opf.ACPModel">ACPModel</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.ACPModel.evaluate_model" href="#ml4opf.ACPModel.evaluate_model">evaluate_model</a></code></li>
<li><code><a title="ml4opf.ACPModel.predict" href="#ml4opf.ACPModel.predict">predict</a></code></li>
<li><code><a title="ml4opf.ACPModel.problem" href="#ml4opf.ACPModel.problem">problem</a></code></li>
<li><code><a title="ml4opf.ACPModel.violation" href="#ml4opf.ACPModel.violation">violation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.ACPProblem" href="#ml4opf.ACPProblem">ACPProblem</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.ACPProblem.default_combos" href="#ml4opf.ACPProblem.default_combos">default_combos</a></code></li>
<li><code><a title="ml4opf.ACPProblem.default_order" href="#ml4opf.ACPProblem.default_order">default_order</a></code></li>
<li><code><a title="ml4opf.ACPProblem.feasibility_check" href="#ml4opf.ACPProblem.feasibility_check">feasibility_check</a></code></li>
<li><code><a title="ml4opf.ACPProblem.violation" href="#ml4opf.ACPProblem.violation">violation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.ACPViolation" href="#ml4opf.ACPViolation">ACPViolation</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.ACPViolation.angle_difference" href="#ml4opf.ACPViolation.angle_difference">angle_difference</a></code></li>
<li><code><a title="ml4opf.ACPViolation.balance_residual" href="#ml4opf.ACPViolation.balance_residual">balance_residual</a></code></li>
<li><code><a title="ml4opf.ACPViolation.calc_violations" href="#ml4opf.ACPViolation.calc_violations">calc_violations</a></code></li>
<li><code><a title="ml4opf.ACPViolation.dva_bound_residual" href="#ml4opf.ACPViolation.dva_bound_residual">dva_bound_residual</a></code></li>
<li><code><a title="ml4opf.ACPViolation.flows_from_voltage" href="#ml4opf.ACPViolation.flows_from_voltage">flows_from_voltage</a></code></li>
<li><code><a title="ml4opf.ACPViolation.flows_from_voltage_bus" href="#ml4opf.ACPViolation.flows_from_voltage_bus">flows_from_voltage_bus</a></code></li>
<li><code><a title="ml4opf.ACPViolation.objective" href="#ml4opf.ACPViolation.objective">objective</a></code></li>
<li><code><a title="ml4opf.ACPViolation.pg_bound_residual" href="#ml4opf.ACPViolation.pg_bound_residual">pg_bound_residual</a></code></li>
<li><code><a title="ml4opf.ACPViolation.qg_bound_residual" href="#ml4opf.ACPViolation.qg_bound_residual">qg_bound_residual</a></code></li>
<li><code><a title="ml4opf.ACPViolation.thermal_residual" href="#ml4opf.ACPViolation.thermal_residual">thermal_residual</a></code></li>
<li><code><a title="ml4opf.ACPViolation.vm_bound_residual" href="#ml4opf.ACPViolation.vm_bound_residual">vm_bound_residual</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.BoundRepair" href="#ml4opf.BoundRepair">BoundRepair</a></code></h4>
<ul class="two-column">
<li><code><a title="ml4opf.BoundRepair.SUPPORTED_METHODS" href="#ml4opf.BoundRepair.SUPPORTED_METHODS">SUPPORTED_METHODS</a></code></li>
<li><code><a title="ml4opf.BoundRepair.clamp" href="#ml4opf.BoundRepair.clamp">clamp</a></code></li>
<li><code><a title="ml4opf.BoundRepair.double_relu" href="#ml4opf.BoundRepair.double_relu">double_relu</a></code></li>
<li><code><a title="ml4opf.BoundRepair.double_sigmoid" href="#ml4opf.BoundRepair.double_sigmoid">double_sigmoid</a></code></li>
<li><code><a title="ml4opf.BoundRepair.double_softplus" href="#ml4opf.BoundRepair.double_softplus">double_softplus</a></code></li>
<li><code><a title="ml4opf.BoundRepair.double_tanh" href="#ml4opf.BoundRepair.double_tanh">double_tanh</a></code></li>
<li><code><a title="ml4opf.BoundRepair.forward" href="#ml4opf.BoundRepair.forward">forward</a></code></li>
<li><code><a title="ml4opf.BoundRepair.load_state_dict" href="#ml4opf.BoundRepair.load_state_dict">load_state_dict</a></code></li>
<li><code><a title="ml4opf.BoundRepair.lower_relu" href="#ml4opf.BoundRepair.lower_relu">lower_relu</a></code></li>
<li><code><a title="ml4opf.BoundRepair.lower_softplus" href="#ml4opf.BoundRepair.lower_softplus">lower_softplus</a></code></li>
<li><code><a title="ml4opf.BoundRepair.none" href="#ml4opf.BoundRepair.none">none</a></code></li>
<li><code><a title="ml4opf.BoundRepair.preprocess_bounds" href="#ml4opf.BoundRepair.preprocess_bounds">preprocess_bounds</a></code></li>
<li><code><a title="ml4opf.BoundRepair.relu" href="#ml4opf.BoundRepair.relu">relu</a></code></li>
<li><code><a title="ml4opf.BoundRepair.sigmoid" href="#ml4opf.BoundRepair.sigmoid">sigmoid</a></code></li>
<li><code><a title="ml4opf.BoundRepair.softplus" href="#ml4opf.BoundRepair.softplus">softplus</a></code></li>
<li><code><a title="ml4opf.BoundRepair.tanh" href="#ml4opf.BoundRepair.tanh">tanh</a></code></li>
<li><code><a title="ml4opf.BoundRepair.upper_relu" href="#ml4opf.BoundRepair.upper_relu">upper_relu</a></code></li>
<li><code><a title="ml4opf.BoundRepair.upper_softplus" href="#ml4opf.BoundRepair.upper_softplus">upper_softplus</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.DCPModel" href="#ml4opf.DCPModel">DCPModel</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.DCPModel.evaluate_model" href="#ml4opf.DCPModel.evaluate_model">evaluate_model</a></code></li>
<li><code><a title="ml4opf.DCPModel.predict" href="#ml4opf.DCPModel.predict">predict</a></code></li>
<li><code><a title="ml4opf.DCPModel.problem" href="#ml4opf.DCPModel.problem">problem</a></code></li>
<li><code><a title="ml4opf.DCPModel.violation" href="#ml4opf.DCPModel.violation">violation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.DCPProblem" href="#ml4opf.DCPProblem">DCPProblem</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.DCPProblem.default_combos" href="#ml4opf.DCPProblem.default_combos">default_combos</a></code></li>
<li><code><a title="ml4opf.DCPProblem.default_order" href="#ml4opf.DCPProblem.default_order">default_order</a></code></li>
<li><code><a title="ml4opf.DCPProblem.feasibility_check" href="#ml4opf.DCPProblem.feasibility_check">feasibility_check</a></code></li>
<li><code><a title="ml4opf.DCPProblem.violation" href="#ml4opf.DCPProblem.violation">violation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.DCPViolation" href="#ml4opf.DCPViolation">DCPViolation</a></code></h4>
<ul class="two-column">
<li><code><a title="ml4opf.DCPViolation.angle_difference" href="#ml4opf.DCPViolation.angle_difference">angle_difference</a></code></li>
<li><code><a title="ml4opf.DCPViolation.balance_residual" href="#ml4opf.DCPViolation.balance_residual">balance_residual</a></code></li>
<li><code><a title="ml4opf.DCPViolation.calc_violations" href="#ml4opf.DCPViolation.calc_violations">calc_violations</a></code></li>
<li><code><a title="ml4opf.DCPViolation.dva_bound_residual" href="#ml4opf.DCPViolation.dva_bound_residual">dva_bound_residual</a></code></li>
<li><code><a title="ml4opf.DCPViolation.nrate_a" href="#ml4opf.DCPViolation.nrate_a">nrate_a</a></code></li>
<li><code><a title="ml4opf.DCPViolation.objective" href="#ml4opf.DCPViolation.objective">objective</a></code></li>
<li><code><a title="ml4opf.DCPViolation.ohm_residual" href="#ml4opf.DCPViolation.ohm_residual">ohm_residual</a></code></li>
<li><code><a title="ml4opf.DCPViolation.pf_bound_residual" href="#ml4opf.DCPViolation.pf_bound_residual">pf_bound_residual</a></code></li>
<li><code><a title="ml4opf.DCPViolation.pf_from_va" href="#ml4opf.DCPViolation.pf_from_va">pf_from_va</a></code></li>
<li><code><a title="ml4opf.DCPViolation.pg_bound_residual" href="#ml4opf.DCPViolation.pg_bound_residual">pg_bound_residual</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.H5Parser" href="#ml4opf.H5Parser">H5Parser</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.H5Parser.apply_mask" href="#ml4opf.H5Parser.apply_mask">apply_mask</a></code></li>
<li><code><a title="ml4opf.H5Parser.convert_to_float32" href="#ml4opf.H5Parser.convert_to_float32">convert_to_float32</a></code></li>
<li><code><a title="ml4opf.H5Parser.extract_test_set" href="#ml4opf.H5Parser.extract_test_set">extract_test_set</a></code></li>
<li><code><a title="ml4opf.H5Parser.filter_by_total_load" href="#ml4opf.H5Parser.filter_by_total_load">filter_by_total_load</a></code></li>
<li><code><a title="ml4opf.H5Parser.get_n_samples" href="#ml4opf.H5Parser.get_n_samples">get_n_samples</a></code></li>
<li><code><a title="ml4opf.H5Parser.keep_n_samples" href="#ml4opf.H5Parser.keep_n_samples">keep_n_samples</a></code></li>
<li><code><a title="ml4opf.H5Parser.make_tree" href="#ml4opf.H5Parser.make_tree">make_tree</a></code></li>
<li><code><a title="ml4opf.H5Parser.parse" href="#ml4opf.H5Parser.parse">parse</a></code></li>
<li><code><a title="ml4opf.H5Parser.remove_infeasible_points" href="#ml4opf.H5Parser.remove_infeasible_points">remove_infeasible_points</a></code></li>
<li><code><a title="ml4opf.H5Parser.validate_path" href="#ml4opf.H5Parser.validate_path">validate_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.HyperSimplexRepair" href="#ml4opf.HyperSimplexRepair">HyperSimplexRepair</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.HyperSimplexRepair.forward" href="#ml4opf.HyperSimplexRepair.forward">forward</a></code></li>
<li><code><a title="ml4opf.HyperSimplexRepair.proportional_projection" href="#ml4opf.HyperSimplexRepair.proportional_projection">proportional_projection</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.JSONParser" href="#ml4opf.JSONParser">JSONParser</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.JSONParser.open" href="#ml4opf.JSONParser.open">open</a></code></li>
<li><code><a title="ml4opf.JSONParser.pad_to_dense" href="#ml4opf.JSONParser.pad_to_dense">pad_to_dense</a></code></li>
<li><code><a title="ml4opf.JSONParser.parse" href="#ml4opf.JSONParser.parse">parse</a></code></li>
<li><code><a title="ml4opf.JSONParser.validate_path" href="#ml4opf.JSONParser.validate_path">validate_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.LDFLoss" href="#ml4opf.LDFLoss">LDFLoss</a></code></h4>
<ul class="two-column">
<li><code><a title="ml4opf.LDFLoss.end_epoch" href="#ml4opf.LDFLoss.end_epoch">end_epoch</a></code></li>
<li><code><a title="ml4opf.LDFLoss.forward" href="#ml4opf.LDFLoss.forward">forward</a></code></li>
<li><code><a title="ml4opf.LDFLoss.init_mults" href="#ml4opf.LDFLoss.init_mults">init_mults</a></code></li>
<li><code><a title="ml4opf.LDFLoss.reset_trackers" href="#ml4opf.LDFLoss.reset_trackers">reset_trackers</a></code></li>
<li><code><a title="ml4opf.LDFLoss.start_epoch" href="#ml4opf.LDFLoss.start_epoch">start_epoch</a></code></li>
<li><code><a title="ml4opf.LDFLoss.update" href="#ml4opf.LDFLoss.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.OPFModel" href="#ml4opf.OPFModel">OPFModel</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.OPFModel.evaluate_model" href="#ml4opf.OPFModel.evaluate_model">evaluate_model</a></code></li>
<li><code><a title="ml4opf.OPFModel.load_from_checkpoint" href="#ml4opf.OPFModel.load_from_checkpoint">load_from_checkpoint</a></code></li>
<li><code><a title="ml4opf.OPFModel.predict" href="#ml4opf.OPFModel.predict">predict</a></code></li>
<li><code><a title="ml4opf.OPFModel.save_checkpoint" href="#ml4opf.OPFModel.save_checkpoint">save_checkpoint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.OPFProblem" href="#ml4opf.OPFProblem">OPFProblem</a></code></h4>
<ul class="two-column">
<li><code><a title="ml4opf.OPFProblem.default_combos" href="#ml4opf.OPFProblem.default_combos">default_combos</a></code></li>
<li><code><a title="ml4opf.OPFProblem.default_order" href="#ml4opf.OPFProblem.default_order">default_order</a></code></li>
<li><code><a title="ml4opf.OPFProblem.default_parse_only" href="#ml4opf.OPFProblem.default_parse_only">default_parse_only</a></code></li>
<li><code><a title="ml4opf.OPFProblem.feasibility_check" href="#ml4opf.OPFProblem.feasibility_check">feasibility_check</a></code></li>
<li><code><a title="ml4opf.OPFProblem.make_dataset" href="#ml4opf.OPFProblem.make_dataset">make_dataset</a></code></li>
<li><code><a title="ml4opf.OPFProblem.parse" href="#ml4opf.OPFProblem.parse">parse</a></code></li>
<li><code><a title="ml4opf.OPFProblem.slice_batch" href="#ml4opf.OPFProblem.slice_batch">slice_batch</a></code></li>
<li><code><a title="ml4opf.OPFProblem.slice_tensor" href="#ml4opf.OPFProblem.slice_tensor">slice_tensor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.OPFViolation" href="#ml4opf.OPFViolation">OPFViolation</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.OPFViolation.SUPPORTED_REDUCTIONS" href="#ml4opf.OPFViolation.SUPPORTED_REDUCTIONS">SUPPORTED_REDUCTIONS</a></code></li>
<li><code><a title="ml4opf.OPFViolation.calc_violations" href="#ml4opf.OPFViolation.calc_violations">calc_violations</a></code></li>
<li><code><a title="ml4opf.OPFViolation.forward" href="#ml4opf.OPFViolation.forward">forward</a></code></li>
<li><code><a title="ml4opf.OPFViolation.objective" href="#ml4opf.OPFViolation.objective">objective</a></code></li>
<li><code><a title="ml4opf.OPFViolation.violation_shapes" href="#ml4opf.OPFViolation.violation_shapes">violation_shapes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ml4opf.ObjectiveLoss" href="#ml4opf.ObjectiveLoss">ObjectiveLoss</a></code></h4>
<ul class="">
<li><code><a title="ml4opf.ObjectiveLoss.SUPPORTED_REDUCTIONS" href="#ml4opf.ObjectiveLoss.SUPPORTED_REDUCTIONS">SUPPORTED_REDUCTIONS</a></code></li>
<li><code><a title="ml4opf.ObjectiveLoss.forward" href="#ml4opf.ObjectiveLoss.forward">forward</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
